import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.image.*;
import java.util.*;
import java.awt.*;
import java.io.*;
import javax.imageio.*;


public class ImageSampler{

//select a portion of the screen
//generate histograme of with prossed image(gassian blure, and grayscale conversion)
//charicterize hisogame signiture
//compare with data base

//FunFact:The aspect ratio of a magic card is 5:7(2.5'' x 3.5'')

public int[] kernalHalfWidths = {100};
public float[] kernalVariance = {0.5f};
public int deltaX[] = {10};
public int deltaY[] = {10};

    public float[] histogram;
    
public int numCards;
public int numSamples = 0 ;
public float[][] dataBase;
    public String[] cardNames;
public String[] fileNames ;
    
    public float[] signitureCovariance;
    public float[][][] cardHypothesisData; // [xSamples][ySamples][N] = signitureCovariance[][]
    public int[][] projections;

public int projectionSamplerWidth = 3;
    public int projectionSupressionThreshold = 0;
public int numberOfOutputs = 1;

    
public ImageSampler(){
this.numCards = 1;
this.numSamples = 3;
dataBase = new float[numCards*numSamples][];

//Name of cards and file location
cardNames = new String[numCards];

cardNames[0] = "Neal Patric Haris";

    int bitMap1[] = { 0x00ff0000, 0x00110000, 0x00ff0000,
                         0x00110000, 0x00770000, 0x00110000,
                         0x00ff0000, 0x00110000, 0x00ff0000};
                         
    BufferedImage img = new BufferedImage(3 , 3, BufferedImage.TYPE_INT_RGB); 
    img.setRGB(0,0,3,3,bitMap,0,1);
//load Cards and build database

float[][] tmp = HistogramImageHash.prosses(img);
//unpack hashes
for(int K = 0; K < this.numSamples;K++){
dataBase[numSamples*I+K] = tmp[K];
//-------System.out.println(Arrays.toString(dataBase[numSamples*I+K]));

}
}
    //box portions of the screen to build the chd(card hypothesis data)
    public void returnMatches(BufferedImage img){
        BufferedImage grayScaleImage = ImageGradient.prosses(img);//convert to gray scale
        
        
        //for each field of view use a different mask
        for(int I = 0; I<kernalHalfWidths.length; I++){

//init values and data
int boxWidth = 2*kernalHalfWidths[I]+1;
            cardHypothesisData = new float[(int)(grayScaleImage.getWidth()/ deltaX[I])][(int)(grayScaleImage.getHeight()/deltaY[I])][numCards*this.numSamples] ;

//Generate Maskes
float[] kernal = ImageHasher.gassianKernel(kernalHalfWidths[I], kernalVariance[I]);
           
            
            //ToDo:add nessary code to allow Window function to start at intermediate points.
            
            for(int J = 0; J<img.getWidth()-boxWidth; J+=deltaX[I]){// for the length of the image
                for(int K = 0; K<img.getHeight()-boxWidth; K+=deltaY[I]){// for the height of the image
            
                    // apply gassian filter to region of image to generate histogram
                    histogram = gassianHistogramWindower(grayScaleImage, J, K, kernal, boxWidth);
        
                    for(int L = 0; L< this.numSamples*numCards; L++){//compare sample with all other signitures
                        signitureCovariance[L] = signatureCompare(histogram, dataBase[L]);//differance in eqilized histograms
System.out.print(signitureCovariance[L]);
                    }
System.out.println();
                }
  
            }
        
        
        //We must now take are data and build the most likely world view
        //ToDo: We will first do a local summation via median window filter.
        //Canidits with the hights score in each position will be bubbled up.


            projections = new int[cardHypothesisData.length - projectionSamplerWidth][cardHypothesisData[0].length - projectionSamplerWidth];
            for(int J = 0; J < cardHypothesisData.length - projectionSamplerWidth; J++){ // in the X direction
                for(int K = 0; K < cardHypothesisData[J].length - projectionSamplerWidth; K++) { // in the Y direction
                    int cardInferance = -1;
                    float score = 0;
                    
                    for(int L = 0; L < numCards*numSamples; L++){//for each card
                        float localScore = 0;
                        
                        for(int M = 0; M < projectionSamplerWidth; M++){ // for windowX
                            for(int N = 0; N < projectionSamplerWidth; N++){//for windowY
                                localScore +=cardHypothesisData[J+N][K+M][L]; //acumlate sum of hypotiss
                            }
                        }
                        
                        if(localScore>projectionSupressionThreshold && localScore>score){
                            cardInferance = L;
                            score = localScore;
                        }
                    }
                    projections[J][K] = cardInferance;
                }
            }
            //acumulate histogram of projections
            int[] histogram = new int[numCards];
            for(int J = 0; J < projections.length; J++){
for(int K = 0; K < projections[J].length; K++){
                if(projections[J][K]!=-1)
                 histogram[projections[J][K]/this.numSamples]++;//divide by number of samples
}
            }
            //determin print order
            int[] outputOrder = new int[numCards];
            int index = 0;
            
            for(int J = 0 ;index < numCards; J++){
                for(int K = 0; K < numCards; K++){
                    if(J == histogram[K]){
                        outputOrder[index] = K;
                        index++;
                    }
                }
            }
            
            //print results
            for(int J = 0; J < numberOfOutputs; J++)
                System.out.println(cardNames[outputOrder[numCards-1-J]]+":"+histogram[outputOrder[numCards-1-J]]);
        }
    }
    
    public static void main(String[] args){
    int bitMap1[] = { 0x00ff0000, 0x00110000, 0x00ff0000,
                         0x00110000, 0x00770000, 0x00110000,
                         0x00ff0000, 0x00110000, 0x00ff0000};
                         
    BufferedImage img = new BufferedImage(3 , 3, BufferedImage.TYPE_INT_RGB); 
    img.setRGB(0,0,3,3,bitMap,0,1);
     
     
    }
    
//method aplays a mask to sample a rectaguler region of the screen
public static float[] gassianHistogramWindower(BufferedImage img, int x0, int y0, float[] mask, int maskWidth){
float[] out = new float[256];
int maskIndex = 0;

for(int I = x0; I < x0 + maskWidth; x0++){
for(int J = y0; J < y0 + maskWidth; J++){
out[(img.getRGB(I, J) & 0x00ff0000) >> 16] += mask[maskIndex];
maskIndex++;
}
}

return out;
}

//uses mean of differances squared to compare two histogram
public static float signatureCompare(float[] arg1, float[] arg2){
float runningSum = 0f;    

for(int I = 0; I < arg1.length; I++)
runningSum +=Math.pow(arg1[I]-arg2[I], 2);

return 1-runningSum/arg1.length;
}  
}

class HistogramImageHash{

    public static float[][] prosses(BufferedImage img){
		float out[][] = new float[3][256];
		BufferedImage gradient = ImageGradient.prosses(img);
		
		int kernalHalfWidth = (img.getWidth()-1)/2;
		int kernalWidth = kernalHalfWidth*2+1;
		
		float[] kernal = ImageHasher.gassianKernel(kernalHalfWidth , 1f);
		
		int kernalIndex = 0;
		for(int I = 0; I < kernalWidth;I++){
			for(int K = 0; K < kernalWidth; K++){
				out[0][((gradient.getRGB(I , K) & 0x00ff0000) >> 16)] += kernal[kernalIndex];
				out[1][((gradient.getRGB(I , K + (img.getHeight()-img.getWidth())/2) & 0x00ff0000) >> 16)] += kernal[kernalIndex];
				out[2][((gradient.getRGB(I , K + (img.getHeight()-img.getWidth())-1) & 0x00ff0000) >> 16)] += kernal[kernalIndex];
				kernalIndex++;
			}
		}
		System.out.println(Arrays.toString(kernal));
		return out;
	}	
}

class ImageGradient{
    private final static float[] xSobel = {-1, 0 , 1, -2, 0, 2, -1, 0, 1};
    private final static float[] ySobel = {1, 2, 1, 0, 0, 0, -1, -2, -1};

    public static BufferedImage prosses(BufferedImage img){
        int[][] xGradient, yGradient;
        BufferedImage out = new BufferedImage(img.getWidth(), img.getHeight(), Transparency.TRANSLUCENT);
        
        BufferedImage im = IntensityMap.remap(img);
        
        
        for(int I = 0; I<im.getWidth()-2; I++){
            for(int J = 0; J<im.getHeight()-2; J++){
                int a , b , n;
                a =(int) mask(im, I, J, xSobel, 3);
                b =(int) mask(im, I, J, ySobel, 3);
                n = (int)(Math.pow(Math.pow(a, 2) + Math.pow(b, 2), .5));//sqrt(a^2+b^2)
                
                if(n>255) n = 255;
                
                Color color = new Color(n, n, n);
                out.setRGB(I, J, color.getRGB());
}
        }
        
        return out;
    }
    
    //applys a wndow funtion to a portion of an image
    //a weighted summation of the red band is perfomed
    
    public static float mask(BufferedImage img, int x0, int y0, float[] bla, int width){
     int index = 0;
     float out =0;
    
     for(int I = x0; I < x0 + width;I++){
     for(int J = y0; J < y0 + width;J++){
     int pixle = img.getRGB(I, J);
     out += bla[index++] * ((pixle & 0x00ff0000) >> 16);
     }
     }
     return out;
    }

  public static int[] quantizePixle(BufferedImage img, int x, int y){
    int clr = img.getRGB(x, y);
                 // red // green // blue
    int[] out = {(clr & 0x00ff0000) >> 16, (clr & 0x0000ff00) >> 8, clr & 0x000000ff};
    return out;
  }

}


class ImageHasher{
  public int halfLength;
  public double variance;

  public ImageHasher(int halfLength, double variance){
   this.halfLength = halfLength;
   this.variance = variance;
  }
  
  public BufferedImage hash(BufferedImage image){
    Kernel kernel = new Kernel(2*halfLength + 1, 2*halfLength + 1, ImageHasher.gassianKernel(this.halfLength, this.variance));
    //Java Native Convolution Object
    ConvolveOp cOP = new ConvolveOp(kernel);
    //apply gassian bluring function
  
    return cOP.filter(image, null);
  }
    
  public static float[] gassianKernel(int halfLength, double variance){
    int length = (int)Math.pow(2*halfLength + 1, 2);
    float[] out = new float[length];
    
    for(int I = -halfLength; I<=halfLength; I++){
      for(int K = -halfLength; K<=halfLength; K++){
        out[(I + halfLength)*(2*halfLength + 1) + K + halfLength] =
                      ((float)(1/(2*Math.PI*Math.pow(variance, 2)))) *((float) Math.exp(-(I*I + K*K)/(2*Math.pow(variance, 2))));
      }
    }

    return out;
  }

  public static float[] gassianKernel(int halfLength, float variance){
    int length = (int)Math.pow(2*halfLength + 1, 2);
    float[] out = new float[length];
    
    for(int I = -halfLength; I<=halfLength; I++){
      for(int K = -halfLength; K<=halfLength; K++){
        out[(I + halfLength)*(2*halfLength + 1) + K + halfLength] =
                      ((float)(1/(2*Math.PI*Math.pow(variance, 2)))) *((float) Math.exp(-(I*I + K*K)/(2*Math.pow(variance, 2))));
      }
    }

    return out;
  }
}

class IntensityMap{
  
  public static BufferedImage remap(BufferedImage img){
    BufferedImage out = new BufferedImage(img.getWidth(), img.getHeight(), Transparency.TRANSLUCENT);
    
    for(int I = 0; I < img.getHeight(); I++){
      for(int J = 0; J < img.getWidth(); J++){
        int[] v = quantizePixle(img, J, I);
        int tmp = (int)(vLength(v)/(Math.pow(3, 0.5)));

        Color nuColor = new Color(tmp, tmp, tmp);
        out.setRGB(J, I, nuColor.getRGB());
      }
    }
    
    return out;
  }

  public static int[] quantizePixle(BufferedImage img, int x, int y){
    int clr = img.getRGB(x, y);
    int red = (clr & 0x00ff0000) >> 16;
    int green = (clr & 0x0000ff00) >> 8;
    int blue = clr & 0x000000ff;
    
    int[] out = {red, green, blue};
    
    return out;
  }
  
  public static float vLength(float[] vector){
    double sum = 0;
    
    for(int I=0; I<vector.length; I++)
      sum += Math.pow(vector[I], 2);
      
    return (float)Math.pow(sum, 0.5);
  }

  public static float vLength(int[] vector){
    double sum = 0;
    
    for(int I=0; I<vector.length; I++)
      sum += Math.pow(vector[I], 2);
      
    return (float)Math.pow(sum, 0.5);
  }
  
  public static float[] vMultiply(float[] vector, float val){
    float[] out = new float[vector.length];
    
    for(int I=0; I<vector.length; I++)
      out[I] = vector[I] * val;
      
    return out;
  }
  
  public static float vDot(float[] arg1, float[] arg2){
    double out=0;
    
    for(int I=0;I<arg1.length;I++)
      out += arg1[I]*arg2[I];
      
    return (float) (out * ( 1 / ( vLength(arg1) * vLength(arg2) ) ));
  }
}
